---@class addonTableAuctionator
local addonTable = select(2, ...)

addonTable.Scanning.Legacy.QueryAllMixin = {}

local FULL_SCAN_EVENTS = {
  "AUCTION_ITEM_LIST_UPDATE",
  "AUCTION_HOUSE_CLOSED",
}

function addonTable.Scanning.Legacy.QueryAllMixin:OnLoad()
  self:SetScript("OnEvent", self.OnEvent)

  self.state = addonTable.Config.Get(addonTable.Config.Options.SCAN_STATE)
end

function addonTable.Scanning.Legacy.QueryAllMixin:ResetData()
  self.scanData = {}
  self.dbKeysMapping = {}
end

function addonTable.Scanning.Legacy.QueryAllMixin:InitiateScan()
  if self:CanInitiate() then
    addonTable.CallbackRegistry:TriggerEvent("ScanStart")

    self.state.TimeOfLastRestricted = time()

    self.inProgress = true

    self:RegisterForEvents()
    addonTable.Utilities.Message(AUCTIONATOR_L_STARTING_FULL_SCAN)

    --Patch to prevent an error being generated by the classic AH code
    if not ITEM_QUALITY_COLORS[-1] then
      ITEM_QUALITY_COLORS[-1] = {r=0, b=0, g=0}
    end

    QueryAuctionItems("", nil, nil, 0, nil, nil, true, false, nil)
    -- 10% complete after making the replicate request
    addonTable.CallbackRegistry:TriggerEvent("ScanProgress", 0.1)
  else
    addonTable.Utilities.Message(self:NextScanMessage())
  end
end

function addonTable.Scanning.Legacy.QueryAllMixin:CanInitiate()
  local _, canDoGetAll = CanSendAuctionQuery()
  return canDoGetAll
end

function addonTable.Scanning.Legacy.QueryAllMixin:NextScanMessage()
  local timeSinceLastScan = time() - (self.state.TimeOfLastRestricted or 0)
  local minutesUntilNextScan = 15 - math.ceil(timeSinceLastScan / 60)
  local secondsUntilNextScan = (15 * 60 - timeSinceLastScan) % 60

  return AUCTIONATOR_L_NEXT_SCAN_MESSAGE:format(minutesUntilNextScan, secondsUntilNextScan)
end

function addonTable.Scanning.Legacy.QueryAllMixin:RegisterForEvents()
  self.otherFramesForEvent = { GetFramesRegisteredForEvent("AUCTION_ITEM_LIST_UPDATE") }
  for _, f in ipairs(self.otherFramesForEvent) do
    f:UnregisterEvent("AUCTION_ITEM_LIST_UPDATE")
  end

  FrameUtil.RegisterFrameForEvents(self, FULL_SCAN_EVENTS)
end

function addonTable.Scanning.Legacy.QueryAllMixin:UnregisterForEvents()
  for _, f in ipairs(self.otherFramesForEvent) do
    f:RegisterEvent("AUCTION_ITEM_LIST_UPDATE")
  end

  FrameUtil.UnregisterFrameForEvents(self, FULL_SCAN_EVENTS)
end

function addonTable.Scanning.Legacy.QueryAllMixin:CacheScanData()
  -- 20% complete after server response
  addonTable.CallbackRegistry:TriggerEvent("ScanProgress", 0.2)

  self:ResetData()
  self.waitingForData = GetNumAuctionItems("list")

  self:ProcessBatch(
    0,
    250,
    self.waitingForData
  )
end

function addonTable.Scanning.Legacy.QueryAllMixin:ProcessBatch(startIndex, stepSize, limit)
  if startIndex >= limit then
    C_Timer.After(2, function()
      if self.waitingForData > 0 then
        self.waitingForData = 0
        self:EndProcessing()
      end
    end)
    return
  end

  -- 20-100% complete when 0-100% through caching the scan
  addonTable.CallbackRegistry:TriggerEvent("ScanProgress", 0.2 + startIndex/limit*0.8)

  local i = startIndex
  while i < startIndex+stepSize and i < limit do
    local info = { GetAuctionItemInfo("list", i) }
    local link = GetAuctionItemLink("list", i)
    local itemID = info[17]

    if itemID == 0 or C_Item.GetItemInfoInstant(itemID) == nil then
      self.waitingForData = self.waitingForData - 1
    elseif not link then
      local item = Item:CreateFromItemID(itemID)
      item:ContinueOnItemLoad((function(index)
        return function()
          -- Don't do anything when the AH window has been closed
          if not self.inProgress then
            return
          end

          local link = GetAuctionItemLink("list", index)

          addonTable.Storage.DBKeyFromLink(link, function(dbKeys)
            self.waitingForData = self.waitingForData - 1

            table.insert(self.scanData, {
              auctionInfo = { GetAuctionItemInfo("list", index) },
              itemLink      = link,
            })
            table.insert(self.dbKeysMapping, dbKeys)

            if self.waitingForData == 0 then
              self:EndProcessing()
            end
          end)
        end
      end)(i))
    else
      addonTable.Storage.DBKeyFromLink(link, function(dbKeys)
        self.waitingForData = self.waitingForData - 1
        table.insert(self.scanData, {
          auctionInfo = info,
          itemLink      = link,
        })
        table.insert(self.dbKeysMapping, dbKeys)

        if self.waitingForData == 0 then
          self:EndProcessing()
        end
      end)
    end

    i = i + 1
  end

  if self.waitingForData == 0 and self.inProgress then
    self:EndProcessing()
  end

  C_Timer.After(0.01, function()
    self:ProcessBatch(startIndex + stepSize, stepSize, limit)
  end)
end

function addonTable.Scanning.Legacy.QueryAllMixin:OnEvent(event, ...)
  if event == "AUCTION_ITEM_LIST_UPDATE" then
    FrameUtil.UnregisterFrameForEvents(self, { "AUCTION_ITEM_LIST_UPDATE" })
    self:CacheScanData()
  elseif event =="AUCTION_HOUSE_CLOSED" then
    self:UnregisterForEvents()

    if self.inProgress then
      self.inProgress = false
      self:ResetData()

      addonTable.Utilities.Message(
        AUCTIONATOR_L_FULL_SCAN_FAILED .. " " .. self:NextScanMessage()
      )
      addonTable.CallbackRegistry:TriggerEvent("ScanFail")
    end
  end
end

local function GetInfo(auctionInfo)
  local available = auctionInfo[3]
  local buyoutPrice = auctionInfo[10]
  local effectivePrice = buyoutPrice / available
    
  return math.ceil(effectivePrice), available
end


local function MergeInfo(scanData, dbKeysMapping)
  local allInfo = {}
  local index = 0

  for index = 1, #scanData do
    local effectivePrice, available = GetInfo(scanData[index].auctionInfo)

    -- available > 0 check just in case Blizzard returns 0 available it
    -- occasionally does on retail and breaking the effectivePrice from GetInfo
    if available > 0 and effectivePrice ~= 0 then
      for _, dbKey in ipairs(dbKeysMapping[index]) do
        if allInfo[dbKey] == nil then
          allInfo[dbKey] = {}
        end

        table.insert(allInfo[dbKey],
          { price = effectivePrice, available = available }
        )
      end
    end
  end

  return allInfo
end

function addonTable.Scanning.Legacy.QueryAllMixin:EndProcessing()
  local rawFullScan = self.scanData

  local count = addonTable.PriceDatabase:ProcessScan(MergeInfo(self.scanData, self.dbKeysMapping))
  addonTable.Utilities.Message(AUCTIONATOR_L_FINISHED_PROCESSING:format(count))

  self.inProgress = false
  self:ResetData()

  self:UnregisterForEvents()

  addonTable.CallbackRegistry:TriggerEvent("ScanComplete", rawFullScan)
end
